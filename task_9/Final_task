Я не успеваю дописать задания, поэтому напишу в каком порядке делать и что делают разные классы

Допиши функции-команды в классе Executor, одна команда - одна функция, кроме функции execute_script, ее напишешь в самом
конце когда вся остальная программа будет работать.
Добавь в классы из пакета dto функцию toString, чтобы элементы коллекции удобочитаемо печатались, унаследуй главным
классом из dto интерфейс comparable  и реализуй соответствующую функцию сравнения (для этого нужна реализовать функции
equals и hashCode в главном классе и возможно в некоторых других, от которых он зависит, если equals главного класса
использует некоторое поле, то для этого поля тоже должен быть переопределен equals), это нужно для корректной сортировки
коллекции.
Создай интерфейс Command этот интерфейс общий для всех команд, и создай классы-команды, которые его имлементят, это
команды без явных аргументов, создай интерфейс  CommandWithArgument, который наследуется от интерфейса Command  и создай
классы - команды с аргументами. (В примере есть пример организации пакетов)

Создай пакет utils и классы, которые в нем должны быть (на самом деле некоторые из этих классов понадобятся тебе раньше,
для реализации некоторых функций в классе Executor) (это вспомогательные классы). Класс Console имеет функции
взаимодействия с консолью, он может принять на вход строку и разделить ее на команду и аргумент, также он умеет запросить
ввод элемента построчно и вернуть готовый объект.
Класс ScriptConsole умеет читать элемент из файла построчно, он нужен сугубо для функции execute_script, поэтому его пиши
в самом конце.
Класс ParserCSV умеет две вещи: преобразовать текст из файла в коллекцию объектов и наоборот.
Класс MapBuilder умеет получать на вход Executor и возвращать мапу с командами.
Как работает программа (метод main):
Сначала проверяем был ли указан файл в аргументах при запуске из командной строки, если нет то конец программы, если
есть, то читаем из файла коллекцию, затем на основе коллекции создаем Executor, а на основе его создаем мапу с командами
далее бесконечный цикл, запрашиваем команду, парсим её на название команды и аргумент, дальше по названию команды
добываем из мапы саму команду, далее проверяем является ли команда, командой с аргументами, если да, то вызываем у неё
метод execute и передаем аргумент, если команда не является командой с аргументами, тогда просто вызываем у неё метод
execute, следующая итерация.

P.S. Еще понадобиться файл с коллекцией, я его назвал data.csv, так как у меня он хранится в корне проекта наряду с
папкой src, то так как при запуске программы нужно указывать путь до файла относительно директории build\libs, то мой
вызов выглядит так:
java -jar джарник ..\..\data.csv
Можно засунуть файл в папку build\libs (кстати советую все тестовые скрипты хранить именно там, тогда при вызове
execute_script, достаточно просто указать название файла), тогда запуск программы будет выглядеть так:
java -jar джарник data.csv

P.S. Недостатки проекта:
- Классы автоматически не документируются в javadoc
- Есть мини баг:
Если написать команду, например, add chto-to, то программа это схавает и просто выполнит команду add без ошибок, хотя
по хорошему у команды add не должно быть аргументов.
